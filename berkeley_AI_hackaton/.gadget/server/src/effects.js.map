{"version":3,"sources":["/app/packages/framework/src/effects.ts"],"sourcesContent":["import type { AnyClient, InternalModelManager, RecordData } from \"@gadgetinc/api-client-core\";\nimport { ChangeTracking, GadgetRecord } from \"@gadgetinc/api-client-core\";\nimport {\n  InternalError,\n  InvalidActionInputError,\n  InvalidStateTransitionError,\n  MisconfiguredActionError,\n  NoSessionForAuthenticationError,\n  PermissionDeniedError,\n  UserNotSetOnSessionError,\n} from \"./errors\";\nimport { Globals, actionContextLocalStorage } from \"./globals\";\nimport { frameworkVersion, modelListIndex, modelsMap } from \"./metadata\";\nimport { AppTenancyKey } from \"./tenancy\";\nimport type { AnyParams, FieldMetadata, ModelDescriptor, ModelMetadata, NotYetTyped } from \"./types\";\nimport { assert } from \"./utils\";\n\nfunction getBelongsToRelationParams(model: ModelMetadata, params: Record<string, any>) {\n  const belongsToParams: any = {};\n\n  for (const field of Object.values(model.fields) as any[]) {\n    if (field.fieldType != \"BelongsTo\") continue;\n    const modelParams = typeof params[model.apiIdentifier] === \"object\" ? params[model.apiIdentifier] : undefined;\n    const belongsToParam =\n      modelParams && typeof modelParams[field.apiIdentifier] === \"object\" ? modelParams[field.apiIdentifier] : undefined;\n    const belongsToId = belongsToParam?.[LINK_PARAM] !== undefined ? belongsToParam[LINK_PARAM] : belongsToParam?.id;\n    if (belongsToId !== undefined) {\n      belongsToParams[`${field.apiIdentifier}Id`] = belongsToId;\n    }\n  }\n\n  return belongsToParams;\n}\n\nexport function createGadgetRecord<Shape>(apiIdentifier: string, data: Shape): GadgetRecord<Shape & { __typename: string }> {\n  const model = getModelByApiIdentifier(apiIdentifier);\n  return new GadgetRecord({\n    ...data,\n    __typename: model.graphqlTypeName,\n  });\n}\n\n/**\n * Applies incoming API params (your modelâ€™s fields) to a record\n *\n * @param params - data passed from API calls, webhook events, or direct user inputs.\n * @param record - object used to pass params to\n */\nexport function applyParams(params: AnyParams, record: GadgetRecord<any>) {\n  const model = getModelByTypename(record.__typename);\n  Object.assign(record, params[model.apiIdentifier], getBelongsToRelationParams(model, params));\n}\n\n/**\n * Get the internal model manager for the model from its maybe-namespaced spot\n */\nconst internalModelManagerForModel = (api: AnyClient, apiIdentifier: string, namespace: string[]) => {\n  const modelPath = [...namespace, apiIdentifier];\n  const manager: InternalModelManager | undefined = Globals.platformModules.lodash().get(api, [\"internal\", ...modelPath]);\n  if (!manager) {\n    throw new InternalError(\n      `Gadget needs but can't find an internal model manager for ${modelPath.join(\n        \".\"\n      )} on the API client -- has it finished regenerating or was it recently removed?`\n    );\n  }\n\n  return manager;\n};\n\n/**\n * Get the internal model manager for the model from its maybe-namespaced spot\n */\nconst internalModelManagerForTypename = (api: AnyClient, typename: string) => {\n  const model = getModelByTypename(typename);\n\n  return internalModelManagerForModel(api, model.apiIdentifier, model.namespace);\n};\n\n/**\n * Saves record to the database:\n * 1. Checks field validations of a given record, then saves the record to the database.\n * 2. Uses your apps Internal API to persist data. This API quickly interacts with data without running any business logic.\n *\n * @param record - object saved to the database\n */\nexport async function save(record: GadgetRecord<any>) {\n  const context = maybeGetActionContextFromLocalStorage();\n  const api = assert(context ? context.api : getCurrentContext().api, \"api client is missing from the current context\");\n  const model = getModelByTypename(record.__typename);\n\n  await (await Globals.modelValidator(model.key)).validate({ api, logger: Globals.logger }, record);\n\n  const internalModelManager = internalModelManagerForTypename(api, record.__typename);\n\n  let result: GadgetRecord<any>;\n\n  if (\"createdAt\" in record && record.createdAt) {\n    result = await internalModelManager.update(record.id, {\n      [model.apiIdentifier]: changedAttributes(model, record),\n    });\n  } else {\n    result = await internalModelManager.create({\n      [model.apiIdentifier]: writableAttributes(model, record),\n    });\n  }\n\n  Object.assign(record, { ...result });\n  record.flushChanges(ChangeTracking.SinceLastPersisted);\n}\n\n/**\n * Deletes record from the database.\n *\n * @param record - object deleted from the database\n */\nexport async function deleteRecord(record: GadgetRecord<any>) {\n  const context = maybeGetActionContextFromLocalStorage();\n\n  const api = assert(context ? context.api : getCurrentContext().api, \"api client is missing from the current context\");\n  const scope = context ? context.scope : {};\n\n  const id = assert(record.id, `record.id not set on record in scope, has the record been persisted?`);\n\n  const internalModelManager = internalModelManagerForTypename(api, record.__typename);\n  await internalModelManager.delete(id);\n\n  scope.recordDeleted = true;\n}\n\nexport const ShopifyShopState = {\n  Installed: { created: \"installed\" },\n  Uninstalled: { created: \"uninstalled\" },\n};\n\nexport const ShopifySyncState = {\n  Created: \"created\",\n  Running: \"running\",\n  Completed: \"completed\",\n  Errored: \"errored\",\n};\n\nexport const ShopifyBulkOperationState = {\n  Created: \"created\",\n  Completed: \"completed\",\n  Canceled: \"canceled\",\n  Failed: \"failed\",\n  Expired: \"expired\",\n};\n\nexport const ShopifySellingPlanGroupProductVariantState = {\n  Started: \"started\",\n  Created: \"created\",\n  Deleted: \"deleted\",\n};\n\nexport const ShopifySellingPlanGroupProductState = {\n  Started: \"started\",\n  Created: \"created\",\n  Deleted: \"deleted\",\n};\n\nexport function transitionState(\n  record: GadgetRecord<any>,\n  transition: {\n    from?: string | Record<string, string>;\n    to: string | Record<string, string>;\n  }\n) {\n  const model = getModelByTypename(record.__typename);\n  const isShopifyModel =\n    model.apiIdentifier === \"shopifyShop\" || model.apiIdentifier === \"shopifySync\" || model.apiIdentifier === \"shopifyBulkOperation\";\n\n  if (isShopifyModel && doesVersionSupportSourceControl()) {\n    // In apps framework version 1.0.0+, we handle the state transition internally to Shopify models based on the above API identifiers.\n    // This function becomes a no-op for those models.\n    return;\n  }\n\n  const stringRecordState = typeof record.state === \"string\" ? record.state : JSON.stringify(record.state);\n  const stringTransitionFrom = typeof transition.from === \"string\" ? transition.from : JSON.stringify(transition.from);\n\n  if (transition.from && stringRecordState !== stringTransitionFrom) {\n    throw new InvalidStateTransitionError(undefined, {\n      state: record.state,\n      expectedFrom: transition.from,\n    });\n  }\n\n  record.state = transition.to;\n}\n\n/**\n * The following is used to power shopifySync model.\n * Learn more about syncing visit our docs: https://docs.gadget.dev/guides/plugins/shopify/syncing-shopify-data#syncing\n */\n\nexport async function shopifySync(params: AnyParams, record: GadgetRecord<any>) {\n  const context = getActionContextFromLocalStorage();\n  const effectAPIs = context.effectAPIs;\n\n  const syncRecord: { syncSince?: Date; id: bigint; shopId: string; models: any; force: boolean } = assert(\n    record,\n    \"cannot start a shop sync from this action\"\n  );\n\n  const shopId = assert(syncRecord.shopId, \"a shop is required to start a sync\");\n\n  if (!syncRecord.models || (Array.isArray(syncRecord.models) && syncRecord.models.every((m) => typeof m == \"string\"))) {\n    try {\n      await effectAPIs.sync(\n        syncRecord.id.toString(),\n        shopId,\n        syncRecord.syncSince,\n        syncRecord.models,\n        syncRecord.force,\n        params.startReason\n      );\n    } catch (error) {\n      Globals.logger.error({ error, connectionSyncId: syncRecord.id }, \"an error occurred starting shop sync\");\n      throw error;\n    }\n  } else {\n    throw new InvalidActionInputError(\"Models must be an array of api identifiers\");\n  }\n}\n\nexport async function abortSync(params: AnyParams, record: GadgetRecord<any>) {\n  const context = getActionContextFromLocalStorage();\n  const effectAPIs = context.effectAPIs;\n\n  const syncRecord: { id: bigint } = assert(record, \"a record is required to abort a shop sync\");\n\n  const syncId = assert(syncRecord.id, \"a sync id is required to start a sync\");\n\n  if (!params.errorMessage) {\n    record.errorMessage = \"Sync aborted\";\n  }\n\n  Globals.logger.info({ userVisible: true, connectionSyncId: syncId }, \"aborting sync\");\n\n  try {\n    await effectAPIs.abortSync(syncId.toString());\n  } catch (error) {\n    Globals.logger.error({ error, connectionSyncId: syncId }, \"an error occurred aborting sync\");\n    throw error;\n  }\n}\n\n/**\n * Applicable for multi-tenant Shopify apps(public apps), or Shopify Customer Extension apps\n * Enforces that the given record is only accessible by the current shop or customer\n *\n * For new records: sets the the current session's `shopId` to the record. If the tenant is a customer then will set the current sessions' customerId to the record.\n * For existing records: Verifies the record objects `shopId` and/or `customerId` matches the one from the current session.\n *\n * *\n * @param params - incoming data validated against the current `shopId`\n * @param record - record used to validate or set the `shopId` on\n * @param {Object} options - Additional options for cross-shop or cross-customer validation\n * @param {string} options.shopBelongsToField - Specifies which related model is used for cross-shop validation.\n * @param {string} options.customerBelongsToField - Specifies which related model is used for cross-customer validation.\n * @param {boolean} options.enforceCustomerTenancy - Whether or not to enforce customer tenacy. Defaults to true.\n */\nexport async function preventCrossShopDataAccess(\n  params: AnyParams,\n  record: GadgetRecord<any>,\n  options?: { shopBelongsToField?: string; customerBelongsToField?: string; enforceCustomerTenancy?: boolean }\n) {\n  const enforceCustomerTenancy = options?.enforceCustomerTenancy ?? true;\n  const context = getActionContextFromLocalStorage();\n\n  if (context.type != \"effect\") {\n    throw new Error(\"Can't prevent cross shop data access outside of an action effect\");\n  }\n  if (!params) {\n    throw new Error(\n      \"The `params` parameter is required in preventCrossShopDataAccess(params, record, options?: { shopBelongsToField: string })\"\n    );\n  }\n  if (!record) {\n    throw new Error(\n      \"The `record` parameter is required in preventCrossShopDataAccess(params, record, options?: { shopBelongsToField: string })\"\n    );\n  }\n  const model = context.model;\n  const appTenancy = context[AppTenancyKey];\n  const shopBelongsToField = options?.shopBelongsToField;\n  const customerBelongsToField = options?.customerBelongsToField;\n\n  // if there's no tenancy let's continue\n  if (appTenancy?.shopify?.shopId === undefined) {\n    return;\n  }\n  // if this effect is not run in the context of a model then it does not apply\n  if (!model) {\n    return;\n  }\n\n  const shopId = String(appTenancy.shopify.shopId);\n  const customerId = appTenancy.shopify.customerId ? String(appTenancy.shopify.customerId) : undefined;\n\n  const input = params[model.apiIdentifier];\n  validateBelongsToLink(input, record, params, shopId, model, ShopifyShopKey, shopBelongsToField, TenantType.Shop);\n\n  if (customerId && enforceCustomerTenancy) {\n    validateBelongsToLink(input, record, params, customerId, model, ShopifyCustomerKey, customerBelongsToField, TenantType.Customer);\n  }\n}\n\nconst validateBelongsToLink = (\n  input: any,\n  record: any,\n  params: AnyParams,\n  tenantId: string,\n  model: ModelDescriptor,\n  relatedModelKey: string,\n  tenantBelongsToField: string | undefined,\n  tenantType: TenantType\n) => {\n  if (relatedModelKey != ShopifyShopKey && relatedModelKey != ShopifyCustomerKey) {\n    throw new Error(\"Validation for tenancy can only be for Shopify Shop or Shopify Customer models\");\n  }\n  // If this effect is being added to the related tenant model (Shopify Shop or Shopify Customer), simply compare the record's ID\n  if (model.key == relatedModelKey) {\n    if (record && String(record.id) !== tenantId) {\n      throw new PermissionDeniedError();\n    }\n    return;\n  }\n\n  const fieldsIsBelongsToRelatedModel = Object.values(model.fields).filter(\n    (f) => f.fieldType === (FieldType.BelongsTo as string) && f.configuration.relatedModelKey === relatedModelKey\n  );\n\n  if (fieldsIsBelongsToRelatedModel.length === 0) {\n    throw new MisconfiguredActionError(`This model is missing a related ${tenantType} field.`);\n  }\n\n  if (fieldsIsBelongsToRelatedModel.length > 1 && !tenantBelongsToField) {\n    throw new MisconfiguredActionError(\n      `This function is missing a related ${tenantType} field option. \\`${tenantType}BelongsToField\\` is a required option parameter if the model has more than one related ${tenantType} field.`\n    );\n  }\n  let relatedTenantField = fieldsIsBelongsToRelatedModel[0];\n\n  if (tenantBelongsToField) {\n    const selectedField = Object.values(model.fields).find((f) => f.apiIdentifier === tenantBelongsToField);\n    if (!selectedField) {\n      throw new MisconfiguredActionError(`The selected ${tenantType} relation field does not exist.`);\n    }\n\n    if (selectedField.fieldType !== (FieldType.BelongsTo as string) || selectedField.configuration.relatedModelKey !== relatedModelKey) {\n      throw new MisconfiguredActionError(\n        `The selected ${tenantType} relation field should be a \\`Belongs To\\` relationship to the \\`Shopify ${Globals.platformModules\n          .lodash()\n          .capitalize(tenantType)}\\` model.`\n      );\n    } else {\n      relatedTenantField = selectedField;\n    }\n  }\n\n  setBelongsToLink(input, record, params, model, relatedTenantField, tenantId);\n};\n\nconst setBelongsToLink = (\n  input: any,\n  record: any,\n  params: AnyParams,\n  model: ModelDescriptor,\n  relatedField: FieldMetadata,\n  tenantId: string\n) => {\n  // if we're trying to set the params to a shop other than the tenant we should reject\n  if (Globals.platformModules.lodash().isObjectLike(input)) {\n    const objectInput = input as Record<string, any>;\n    if (objectInput[relatedField.apiIdentifier]) {\n      if (String(objectInput[relatedField.apiIdentifier][LINK_PARAM]) !== tenantId) {\n        throw new PermissionDeniedError();\n      }\n    } else {\n      objectInput[relatedField.apiIdentifier] = {\n        [LINK_PARAM]: tenantId,\n      };\n    }\n  } else {\n    params[model.apiIdentifier] = {\n      [relatedField.apiIdentifier]: {\n        [LINK_PARAM]: tenantId,\n      },\n    };\n  }\n\n  if (record) {\n    const value = record.getField(relatedField.apiIdentifier);\n    // if the record doesn't have a shop set then anyone can update it\n    if (value) {\n      const recordShopId = typeof value === \"object\" ? value[LINK_PARAM] : value;\n      if (String(recordShopId) !== tenantId) {\n        throw new PermissionDeniedError();\n      }\n    } else {\n      // we have to re-apply the params to the record to ensure that this still works correctly if it occurs after \"applyParams\"\n      record.setField(relatedField.apiIdentifier, {\n        [LINK_PARAM]: tenantId,\n      });\n    }\n  }\n};\n\n/**\n * Updates the state of a `bulkOperation` record from Shopify when the operation completes.\n *\n * @param record - the `bulkOperation` record updated\n */\nexport async function finishBulkOperation(record: GadgetRecord<any>) {\n  if (!record?.id) {\n    Globals.logger.warn(`Expected bulk operation record to be present for action`);\n    return;\n  }\n\n  const context = getActionContextFromLocalStorage();\n  const shopifyAPI = await (context.connections as Record<string, any>).shopify.forShopId(record.shopId);\n  if (!shopifyAPI) {\n    Globals.logger.error(`Could not instantiate Shopify client for shop ID ${record.shopId}`);\n    return;\n  }\n  const bulkOperation = (\n    await shopifyAPI.graphql(`query {\n        node(id: \"${ShopifyBulkOperationGIDForId(record.id)}\") {\n          ... on BulkOperation {\n            id\n            status\n            errorCode\n            createdAt\n            completedAt\n            objectCount\n            fileSize\n            url\n            type\n            partialDataUrl\n            rootObjectCount\n          }\n        }\n      }`)\n  ).node;\n  // normalize the mixed upper/lowercase (GraphQL/REST) to lowercase\n  const { status, errorCode, type } = bulkOperation;\n  Object.assign(record, {\n    ...bulkOperation,\n    status: status?.toLowerCase(),\n    errorCode: errorCode?.toLowerCase(),\n    type: type?.toLowerCase(),\n    id: record.id,\n  });\n}\n\n/**\n * Syncs Shopify models across all models\n *\n * @param params - list of Shopify app credentials to sync data from\n * @param syncSince - starting point for data sync (default: all time)\n * @param models - list of model names to sync data from\n * @param force - enforces syncswithout checking if they're up to date\n * @param startReason - a string reason stored on the created 'shopifySync' records\n */\nexport async function globalShopifySync(params: {\n  apiKeys: string[];\n  syncSince: string;\n  models: string[];\n  force: boolean;\n  startReason: string;\n}) {\n  const context = maybeGetActionContextFromLocalStorage();\n  const effectAPIs = assert(\n    context ? context.effectAPIs : getCurrentContext().effectAPIs,\n    \"effect apis is missing from the current context\"\n  );\n  const api = assert(context ? context.api : getCurrentContext().api, \"api client is missing from the current context\");\n\n  const { apiKeys, syncSince, models, force, startReason } = params;\n\n  const {\n    shopModelIdentifier,\n    installedViaKeyFieldIdentifier,\n    shopifySyncModelApiIdentifier,\n    runShopifySyncAction,\n    accessTokenIdentifier,\n    forceFieldIdentifier,\n  } = await effectAPIs.getSyncIdentifiers();\n  const manager = internalModelManagerForModel(api, shopModelIdentifier, []);\n\n  const pageSize = 250;\n  let pageInfo: { first?: number; endCursor?: string; hasNextPage: boolean } = { first: pageSize, hasNextPage: true };\n  const results: { id: string; domain: string; state: Record<string, any>; [key: string]: any }[] = [];\n\n  if (apiKeys && apiKeys.length > 0) {\n    try {\n      while (pageInfo.hasNextPage) {\n        const records = await manager.findMany({\n          filter: {\n            [installedViaKeyFieldIdentifier]: {\n              in: apiKeys,\n            },\n            state: {\n              inState: \"created.installed\",\n            },\n            planName: {\n              notIn: [\"frozen\", \"fraudulent\", \"cancelled\"],\n            },\n          },\n          first: pageInfo.first,\n          after: pageInfo.endCursor,\n        });\n        results.push(...(records as any[]));\n        pageInfo = records.pagination.pageInfo;\n      }\n    } catch (error) {\n      Globals.logger.info({ userVisible: true, error, apiKeys }, \"could not get shops for all API keys\");\n      throw error;\n    }\n\n    for (const result of results) {\n      // skip the sync if there is no accessToken set or if the state is uninstalled\n      if (Globals.platformModules.lodash().isEmpty(result[accessTokenIdentifier]) || result.state?.created == \"uninstalled\") {\n        Globals.logger.info({ shopId: result.id }, \"skipping sync for shop without access token or is uninstalled\");\n        continue;\n      }\n\n      try {\n        const shopifySyncModelManager = Globals.platformModules.lodash().get(api, runShopifySyncAction.dotNotationPath);\n        await shopifySyncModelManager[runShopifySyncAction.apiIdentifier]({\n          [shopifySyncModelApiIdentifier]: {\n            shop: {\n              _link: result.id,\n            },\n            domain: result.domain,\n            syncSince,\n            models,\n            ...(forceFieldIdentifier ? { force } : undefined),\n          },\n          startReason,\n        });\n      } catch (error) {\n        // log that the sync could not be started for the shop but continue\n        Globals.logger.warn({ userVisible: true, error, shop: result }, \"couldn't start sync for shop\");\n      }\n    }\n  } else {\n    throw new InvalidActionInputError(\"missing at least 1 api key\");\n  }\n}\n\nexport function legacySetUser() {\n  const context = getActionContextFromLocalStorage();\n\n  if (!context.scope.authenticatedUser) {\n    throw new UserNotSetOnSessionError(\n      \"The authenticated user could not be saved to the session when logging in. Make sure the user has a role assigned to them.\"\n    );\n  }\n  if (!context.session) {\n    throw new NoSessionForAuthenticationError(\n      \"Unable to authenticate because the request was made with no session in context to transition.\"\n    );\n  }\n  context.session.set(\"user\", { [LINK_PARAM]: context.scope.authenticatedUser.id });\n}\n\nexport function legacyUnsetUser() {\n  const context = getActionContextFromLocalStorage();\n\n  if (!context.session) {\n    throw new NoSessionForAuthenticationError(\"Unable to unset users on session because the request was made with no session.\");\n  }\n  context.session.delete(\"user\");\n}\n\nexport async function legacySuccessfulAuthentication(params: AnyParams) {\n  const context = getActionContextFromLocalStorage();\n  const { api, scope } = context;\n  const manager = api.internal.user as InternalModelManager;\n\n  const user = (await manager.findMany({ filter: { email: { equals: params.email } } }))[0];\n  let result = false;\n  if (user && params.password && user.password?.hash) {\n    if (await Globals.platformModules.bcrypt().compare(params.password, user.password.hash)) {\n      scope.authenticatedUser = user;\n      result = true;\n    }\n  }\n  Globals.logger.info({ email: params.email, userId: user?.id, result }, \"login attempt\");\n\n  if (!result) {\n    throw new Error(\"Invalid email or password\");\n  }\n}\n\n/**\n * @private helper functions and variables\n */\n\nfunction doesVersionSupportSourceControl(): boolean {\n  return Globals.platformModules.compareVersions().satisfies(frameworkVersion, \">=1.0.0\");\n}\n\n/**\n * @private Get action context without `params` and `record` from async local storage.\n */\nfunction getActionContextFromLocalStorage() {\n  return assert(actionContextLocalStorage.getStore(), \"this effect function should only be called from within an action\");\n}\n\n/**\n * @private Similar to `getActionContextFromLocalStorage` but returns `undefined` if there is no action context. (i.e. possibly called from a route)\n */\nfunction maybeGetActionContextFromLocalStorage() {\n  return actionContextLocalStorage.getStore();\n}\n\nfunction getCurrentContext() {\n  return assert(Globals.requestContext.get(\"requestContext\"), \"no gadget context found on request\");\n}\n\nconst LINK_PARAM = \"_link\";\n\nfunction writableAttributes(model: ModelMetadata, record: GadgetRecord<RecordData>) {\n  const fieldsByApiIdentifier = Globals.platformModules.lodash().keyBy(Object.values(model.fields) as NotYetTyped[], \"apiIdentifier\");\n  return Globals.platformModules.lodash().pickBy(record, (v: any, k: any) => fieldsByApiIdentifier[k]?.internalWritable);\n}\n\nfunction changedAttributes(model: ModelMetadata, record: GadgetRecord<RecordData>) {\n  const changes = record.changes();\n  const attributes = Object.keys(changes).reduce((attrs, key) => {\n    attrs[key] = record[key];\n    return attrs;\n  }, {} as any);\n  return writableAttributes(model, attributes);\n}\n\nconst getModelByApiIdentifier = (apiIdentifier: string): ModelMetadata => {\n  const typename = modelListIndex[`api:${apiIdentifier}`];\n  if (!typename) {\n    throw new InternalError(`Model ${apiIdentifier} not found in available model metadata`, {\n      availableApiIdentifiers: Object.keys(modelListIndex),\n    });\n  }\n\n  return getModelByTypename(typename);\n};\n\nconst getModelByTypename = (typename: string): ModelMetadata => {\n  if (!typename) {\n    throw new InternalError(`No typename found on record, __typename must be set for accessing model metadata`);\n  }\n\n  const model = modelsMap[typename];\n  if (!model) {\n    throw new InternalError(`Model with typename ${typename} not found in available model metadata`, {\n      availableTypenames: Object.keys(modelsMap),\n    });\n  }\n\n  return model;\n};\n\nexport enum FieldType {\n  ID = \"ID\",\n  Number = \"Number\",\n  String = \"String\",\n  Enum = \"Enum\",\n  RichText = \"RichText\",\n  DateTime = \"DateTime\",\n  Email = \"Email\",\n  URL = \"URL\",\n  Money = \"Money\",\n  File = \"File\",\n  Color = \"Color\",\n  Password = \"Password\",\n  Computed = \"Computed\",\n  HasManyThrough = \"HasManyThrough\",\n  BelongsTo = \"BelongsTo\",\n  HasMany = \"HasMany\",\n  HasOne = \"HasOne\",\n  Boolean = \"Boolean\",\n  Model = \"Model\",\n  Object = \"Object\",\n  Array = \"Array\",\n  JSON = \"JSON\",\n  Code = \"Code\",\n  EncryptedString = \"EncryptedString\",\n  Vector = \"Vector\",\n  /**\n   * Any value at all.\n   * Prefer FieldType.JSON where possible, it's more descriptive.\n   */\n  Any = \"Any\",\n  Null = \"Null\",\n  RecordState = \"RecordState\",\n  RoleAssignments = \"RoleAssignments\",\n}\n\nconst enum TenantType {\n  Shop = \"shop\",\n  Customer = \"customer\",\n}\n\nconst shopifyModelKey = (modelName: string) => {\n  const modelKey = modelName.replaceAll(\" \", \"\");\n  return `DataModel-Shopify-${modelKey}`;\n};\n\nconst ShopifyShopKey = shopifyModelKey(\"Shop\");\nconst ShopifyCustomerKey = shopifyModelKey(\"Customer\");\n\nconst ShopifyBulkOperationGIDForId = (id: string) => `gid://shopify/BulkOperation/${id}`;\n"],"names":["ShopifyBulkOperationState","ShopifySellingPlanGroupProductState","ShopifySellingPlanGroupProductVariantState","ShopifyShopState","ShopifySyncState","abortSync","applyParams","createGadgetRecord","deleteRecord","finishBulkOperation","globalShopifySync","legacySetUser","legacySuccessfulAuthentication","legacyUnsetUser","preventCrossShopDataAccess","save","shopifySync","transitionState","getBelongsToRelationParams","model","params","belongsToParams","field","Object","values","fields","fieldType","modelParams","apiIdentifier","undefined","belongsToParam","belongsToId","LINK_PARAM","id","data","getModelByApiIdentifier","GadgetRecord","__typename","graphqlTypeName","record","getModelByTypename","assign","internalModelManagerForModel","api","namespace","modelPath","manager","Globals","platformModules","lodash","get","InternalError","join","internalModelManagerForTypename","typename","context","maybeGetActionContextFromLocalStorage","assert","getCurrentContext","modelValidator","key","validate","logger","internalModelManager","result","createdAt","update","changedAttributes","create","writableAttributes","flushChanges","ChangeTracking","SinceLastPersisted","scope","delete","recordDeleted","Installed","created","Uninstalled","Created","Running","Completed","Errored","Canceled","Failed","Expired","Started","Deleted","transition","isShopifyModel","doesVersionSupportSourceControl","stringRecordState","state","JSON","stringify","stringTransitionFrom","from","InvalidStateTransitionError","expectedFrom","to","getActionContextFromLocalStorage","effectAPIs","syncRecord","shopId","models","Array","isArray","every","m","sync","toString","syncSince","force","startReason","error","connectionSyncId","InvalidActionInputError","syncId","errorMessage","info","userVisible","options","enforceCustomerTenancy","type","Error","appTenancy","AppTenancyKey","shopBelongsToField","customerBelongsToField","shopify","String","customerId","input","validateBelongsToLink","ShopifyShopKey","ShopifyCustomerKey","tenantId","relatedModelKey","tenantBelongsToField","tenantType","PermissionDeniedError","fieldsIsBelongsToRelatedModel","filter","f","configuration","length","MisconfiguredActionError","relatedTenantField","selectedField","find","capitalize","setBelongsToLink","relatedField","isObjectLike","objectInput","value","getField","recordShopId","setField","warn","shopifyAPI","connections","forShopId","bulkOperation","graphql","ShopifyBulkOperationGIDForId","node","status","errorCode","toLowerCase","apiKeys","shopModelIdentifier","installedViaKeyFieldIdentifier","shopifySyncModelApiIdentifier","runShopifySyncAction","accessTokenIdentifier","forceFieldIdentifier","getSyncIdentifiers","pageSize","pageInfo","first","hasNextPage","results","records","findMany","in","inState","planName","notIn","after","endCursor","push","pagination","isEmpty","shopifySyncModelManager","dotNotationPath","shop","_link","domain","authenticatedUser","UserNotSetOnSessionError","session","NoSessionForAuthenticationError","set","internal","user","email","equals","password","hash","bcrypt","compare","userId","compareVersions","satisfies","frameworkVersion","actionContextLocalStorage","getStore","requestContext","fieldsByApiIdentifier","keyBy","pickBy","v","k","internalWritable","changes","attributes","keys","reduce","attrs","modelListIndex","availableApiIdentifiers","modelsMap","availableTypenames","FieldType","shopifyModelKey","modelName","modelKey","replaceAll"],"mappings":";;;;;;;;;;;;;;IA8IaA,yBAAyB;eAAzBA;;IAcAC,mCAAmC;eAAnCA;;IANAC,0CAA0C;eAA1CA;;IApBAC,gBAAgB;eAAhBA;;IAKAC,gBAAgB;eAAhBA;;IA4FSC,SAAS;eAATA;;IAnLNC,WAAW;eAAXA;;IAdAC,kBAAkB;eAAlBA;;IAkFMC,YAAY;eAAZA;;IA4SAC,mBAAmB;eAAnBA;;IAmDAC,iBAAiB;eAAjBA;;IAuFNC,aAAa;eAAbA;;IAyBMC,8BAA8B;eAA9BA;;IATNC,eAAe;eAAfA;;IAlTMC,0BAA0B;eAA1BA;;IAlLAC,IAAI;eAAJA;;IA+GAC,WAAW;eAAXA;;IAnCNC,eAAe;eAAfA;;;;yBAjK6B;;;;;;wBAStC;yBAC4C;0BACS;yBAC9B;uBAEP;AAEvB,SAASC,2BAA2BC,KAAoB,EAAEC,MAA2B;IACnF,MAAMC,kBAAuB,CAAC;IAE9B,KAAK,MAAMC,SAASC,OAAOC,MAAM,CAACL,MAAMM,MAAM,EAAY;QACxD,IAAIH,MAAMI,SAAS,IAAI,aAAa;QACpC,MAAMC,cAAc,OAAOP,MAAM,CAACD,MAAMS,aAAa,CAAC,KAAK,WAAWR,MAAM,CAACD,MAAMS,aAAa,CAAC,GAAGC;QACpG,MAAMC,iBACJH,eAAe,OAAOA,WAAW,CAACL,MAAMM,aAAa,CAAC,KAAK,WAAWD,WAAW,CAACL,MAAMM,aAAa,CAAC,GAAGC;QAC3G,MAAME,cAAcD,gBAAgB,CAACE,WAAW,KAAKH,YAAYC,cAAc,CAACE,WAAW,GAAGF,gBAAgBG;QAC9G,IAAIF,gBAAgBF,WAAW;YAC7BR,eAAe,CAAC,CAAC,EAAEC,MAAMM,aAAa,CAAC,EAAE,CAAC,CAAC,GAAGG;QAChD;IACF;IAEA,OAAOV;AACT;AAEO,SAASd,mBAA0BqB,aAAqB,EAAEM,IAAW;IAC1E,MAAMf,QAAQgB,wBAAwBP;IACtC,OAAO,IAAIQ,CAAAA,gBAAW,cAAC,CAAC;QACtB,GAAGF,IAAI;QACPG,YAAYlB,MAAMmB,eAAe;IACnC;AACF;AAQO,SAAShC,YAAYc,MAAiB,EAAEmB,MAAyB;IACtE,MAAMpB,QAAQqB,mBAAmBD,OAAOF,UAAU;IAClDd,OAAOkB,MAAM,CAACF,QAAQnB,MAAM,CAACD,MAAMS,aAAa,CAAC,EAAEV,2BAA2BC,OAAOC;AACvF;AAEA;;CAEC,GACD,MAAMsB,+BAA+B,CAACC,KAAgBf,eAAuBgB;IAC3E,MAAMC,YAAY;WAAID;QAAWhB;KAAc;IAC/C,MAAMkB,UAA4CC,gBAAO,CAACC,eAAe,CAACC,MAAM,GAAGC,GAAG,CAACP,KAAK;QAAC;WAAeE;KAAU;IACtH,IAAI,CAACC,SAAS;QACZ,MAAM,IAAIK,qBAAa,CACrB,CAAC,0DAA0D,EAAEN,UAAUO,IAAI,CACzE,KACA,8EAA8E,CAAC;IAErF;IAEA,OAAON;AACT;AAEA;;CAEC,GACD,MAAMO,kCAAkC,CAACV,KAAgBW;IACvD,MAAMnC,QAAQqB,mBAAmBc;IAEjC,OAAOZ,6BAA6BC,KAAKxB,MAAMS,aAAa,EAAET,MAAMyB,SAAS;AAC/E;AASO,eAAe7B,KAAKwB,MAAyB;IAClD,MAAMgB,UAAUC;IAChB,MAAMb,MAAMc,IAAAA,aAAM,EAACF,UAAUA,QAAQZ,GAAG,GAAGe,oBAAoBf,GAAG,EAAE;IACpE,MAAMxB,QAAQqB,mBAAmBD,OAAOF,UAAU;IAElD,MAAM,AAAC,CAAA,MAAMU,gBAAO,CAACY,cAAc,CAACxC,MAAMyC,GAAG,CAAA,EAAGC,QAAQ,CAAC;QAAElB;QAAKmB,QAAQf,gBAAO,CAACe,MAAM;IAAC,GAAGvB;IAE1F,MAAMwB,uBAAuBV,gCAAgCV,KAAKJ,OAAOF,UAAU;IAEnF,IAAI2B;IAEJ,IAAI,eAAezB,UAAUA,OAAO0B,SAAS,EAAE;QAC7CD,SAAS,MAAMD,qBAAqBG,MAAM,CAAC3B,OAAON,EAAE,EAAE;YACpD,CAACd,MAAMS,aAAa,CAAC,EAAEuC,kBAAkBhD,OAAOoB;QAClD;IACF,OAAO;QACLyB,SAAS,MAAMD,qBAAqBK,MAAM,CAAC;YACzC,CAACjD,MAAMS,aAAa,CAAC,EAAEyC,mBAAmBlD,OAAOoB;QACnD;IACF;IAEAhB,OAAOkB,MAAM,CAACF,QAAQ;QAAE,GAAGyB,MAAM;IAAC;IAClCzB,OAAO+B,YAAY,CAACC,+BAAc,CAACC,kBAAkB;AACvD;AAOO,eAAehE,aAAa+B,MAAyB;IAC1D,MAAMgB,UAAUC;IAEhB,MAAMb,MAAMc,IAAAA,aAAM,EAACF,UAAUA,QAAQZ,GAAG,GAAGe,oBAAoBf,GAAG,EAAE;IACpE,MAAM8B,QAAQlB,UAAUA,QAAQkB,KAAK,GAAG,CAAC;IAEzC,MAAMxC,KAAKwB,IAAAA,aAAM,EAAClB,OAAON,EAAE,EAAE,CAAC,oEAAoE,CAAC;IAEnG,MAAM8B,uBAAuBV,gCAAgCV,KAAKJ,OAAOF,UAAU;IACnF,MAAM0B,qBAAqBW,MAAM,CAACzC;IAElCwC,MAAME,aAAa,GAAG;AACxB;AAEO,MAAMxE,mBAAmB;IAC9ByE,WAAW;QAAEC,SAAS;IAAY;IAClCC,aAAa;QAAED,SAAS;IAAc;AACxC;AAEO,MAAMzE,mBAAmB;IAC9B2E,SAAS;IACTC,SAAS;IACTC,WAAW;IACXC,SAAS;AACX;AAEO,MAAMlF,4BAA4B;IACvC+E,SAAS;IACTE,WAAW;IACXE,UAAU;IACVC,QAAQ;IACRC,SAAS;AACX;AAEO,MAAMnF,6CAA6C;IACxDoF,SAAS;IACTP,SAAS;IACTQ,SAAS;AACX;AAEO,MAAMtF,sCAAsC;IACjDqF,SAAS;IACTP,SAAS;IACTQ,SAAS;AACX;AAEO,SAAStE,gBACdsB,MAAyB,EACzBiD,UAGC;IAED,MAAMrE,QAAQqB,mBAAmBD,OAAOF,UAAU;IAClD,MAAMoD,iBACJtE,MAAMS,aAAa,KAAK,iBAAiBT,MAAMS,aAAa,KAAK,iBAAiBT,MAAMS,aAAa,KAAK;IAE5G,IAAI6D,kBAAkBC,mCAAmC;QACvD,oIAAoI;QACpI,kDAAkD;QAClD;IACF;IAEA,MAAMC,oBAAoB,OAAOpD,OAAOqD,KAAK,KAAK,WAAWrD,OAAOqD,KAAK,GAAGC,KAAKC,SAAS,CAACvD,OAAOqD,KAAK;IACvG,MAAMG,uBAAuB,OAAOP,WAAWQ,IAAI,KAAK,WAAWR,WAAWQ,IAAI,GAAGH,KAAKC,SAAS,CAACN,WAAWQ,IAAI;IAEnH,IAAIR,WAAWQ,IAAI,IAAIL,sBAAsBI,sBAAsB;QACjE,MAAM,IAAIE,mCAA2B,CAACpE,WAAW;YAC/C+D,OAAOrD,OAAOqD,KAAK;YACnBM,cAAcV,WAAWQ,IAAI;QAC/B;IACF;IAEAzD,OAAOqD,KAAK,GAAGJ,WAAWW,EAAE;AAC9B;AAOO,eAAenF,YAAYI,MAAiB,EAAEmB,MAAyB;IAC5E,MAAMgB,UAAU6C;IAChB,MAAMC,aAAa9C,QAAQ8C,UAAU;IAErC,MAAMC,aAA4F7C,IAAAA,aAAM,EACtGlB,QACA;IAGF,MAAMgE,SAAS9C,IAAAA,aAAM,EAAC6C,WAAWC,MAAM,EAAE;IAEzC,IAAI,CAACD,WAAWE,MAAM,IAAKC,MAAMC,OAAO,CAACJ,WAAWE,MAAM,KAAKF,WAAWE,MAAM,CAACG,KAAK,CAAC,CAACC,IAAM,OAAOA,KAAK,WAAY;QACpH,IAAI;YACF,MAAMP,WAAWQ,IAAI,CACnBP,WAAWrE,EAAE,CAAC6E,QAAQ,IACtBP,QACAD,WAAWS,SAAS,EACpBT,WAAWE,MAAM,EACjBF,WAAWU,KAAK,EAChB5F,OAAO6F,WAAW;QAEtB,EAAE,OAAOC,OAAO;YACdnE,gBAAO,CAACe,MAAM,CAACoD,KAAK,CAAC;gBAAEA;gBAAOC,kBAAkBb,WAAWrE,EAAE;YAAC,GAAG;YACjE,MAAMiF;QACR;IACF,OAAO;QACL,MAAM,IAAIE,+BAAuB,CAAC;IACpC;AACF;AAEO,eAAe/G,UAAUe,MAAiB,EAAEmB,MAAyB;IAC1E,MAAMgB,UAAU6C;IAChB,MAAMC,aAAa9C,QAAQ8C,UAAU;IAErC,MAAMC,aAA6B7C,IAAAA,aAAM,EAAClB,QAAQ;IAElD,MAAM8E,SAAS5D,IAAAA,aAAM,EAAC6C,WAAWrE,EAAE,EAAE;IAErC,IAAI,CAACb,OAAOkG,YAAY,EAAE;QACxB/E,OAAO+E,YAAY,GAAG;IACxB;IAEAvE,gBAAO,CAACe,MAAM,CAACyD,IAAI,CAAC;QAAEC,aAAa;QAAML,kBAAkBE;IAAO,GAAG;IAErE,IAAI;QACF,MAAMhB,WAAWhG,SAAS,CAACgH,OAAOP,QAAQ;IAC5C,EAAE,OAAOI,OAAO;QACdnE,gBAAO,CAACe,MAAM,CAACoD,KAAK,CAAC;YAAEA;YAAOC,kBAAkBE;QAAO,GAAG;QAC1D,MAAMH;IACR;AACF;AAiBO,eAAepG,2BACpBM,MAAiB,EACjBmB,MAAyB,EACzBkF,OAA4G;IAE5G,MAAMC,yBAAyBD,SAASC,0BAA0B;IAClE,MAAMnE,UAAU6C;IAEhB,IAAI7C,QAAQoE,IAAI,IAAI,UAAU;QAC5B,MAAM,IAAIC,MAAM;IAClB;IACA,IAAI,CAACxG,QAAQ;QACX,MAAM,IAAIwG,MACR;IAEJ;IACA,IAAI,CAACrF,QAAQ;QACX,MAAM,IAAIqF,MACR;IAEJ;IACA,MAAMzG,QAAQoC,QAAQpC,KAAK;IAC3B,MAAM0G,aAAatE,OAAO,CAACuE,sBAAa,CAAC;IACzC,MAAMC,qBAAqBN,SAASM;IACpC,MAAMC,yBAAyBP,SAASO;IAExC,uCAAuC;IACvC,IAAIH,YAAYI,SAAS1B,WAAW1E,WAAW;QAC7C;IACF;IACA,6EAA6E;IAC7E,IAAI,CAACV,OAAO;QACV;IACF;IAEA,MAAMoF,SAAS2B,OAAOL,WAAWI,OAAO,CAAC1B,MAAM;IAC/C,MAAM4B,aAAaN,WAAWI,OAAO,CAACE,UAAU,GAAGD,OAAOL,WAAWI,OAAO,CAACE,UAAU,IAAItG;IAE3F,MAAMuG,QAAQhH,MAAM,CAACD,MAAMS,aAAa,CAAC;IACzCyG,sBAAsBD,OAAO7F,QAAQnB,QAAQmF,QAAQpF,OAAOmH,gBAAgBP;IAE5E,IAAII,cAAcT,wBAAwB;QACxCW,sBAAsBD,OAAO7F,QAAQnB,QAAQ+G,YAAYhH,OAAOoH,oBAAoBP;IACtF;AACF;AAEA,MAAMK,wBAAwB,CAC5BD,OACA7F,QACAnB,QACAoH,UACArH,OACAsH,iBACAC,sBACAC;IAEA,IAAIF,mBAAmBH,kBAAkBG,mBAAmBF,oBAAoB;QAC9E,MAAM,IAAIX,MAAM;IAClB;IACA,+HAA+H;IAC/H,IAAIzG,MAAMyC,GAAG,IAAI6E,iBAAiB;QAChC,IAAIlG,UAAU2F,OAAO3F,OAAON,EAAE,MAAMuG,UAAU;YAC5C,MAAM,IAAII,6BAAqB;QACjC;QACA;IACF;IAEA,MAAMC,gCAAgCtH,OAAOC,MAAM,CAACL,MAAMM,MAAM,EAAEqH,MAAM,CACtE,CAACC,IAAMA,EAAErH,SAAS,oBAAwCqH,EAAEC,aAAa,CAACP,eAAe,KAAKA;IAGhG,IAAII,8BAA8BI,MAAM,KAAK,GAAG;QAC9C,MAAM,IAAIC,gCAAwB,CAAC,CAAC,gCAAgC,EAAEP,WAAW,OAAO,CAAC;IAC3F;IAEA,IAAIE,8BAA8BI,MAAM,GAAG,KAAK,CAACP,sBAAsB;QACrE,MAAM,IAAIQ,gCAAwB,CAChC,CAAC,mCAAmC,EAAEP,WAAW,iBAAiB,EAAEA,WAAW,uFAAuF,EAAEA,WAAW,OAAO,CAAC;IAE/L;IACA,IAAIQ,qBAAqBN,6BAA6B,CAAC,EAAE;IAEzD,IAAIH,sBAAsB;QACxB,MAAMU,gBAAgB7H,OAAOC,MAAM,CAACL,MAAMM,MAAM,EAAE4H,IAAI,CAAC,CAACN,IAAMA,EAAEnH,aAAa,KAAK8G;QAClF,IAAI,CAACU,eAAe;YAClB,MAAM,IAAIF,gCAAwB,CAAC,CAAC,aAAa,EAAEP,WAAW,+BAA+B,CAAC;QAChG;QAEA,IAAIS,cAAc1H,SAAS,oBAAwC0H,cAAcJ,aAAa,CAACP,eAAe,KAAKA,iBAAiB;YAClI,MAAM,IAAIS,gCAAwB,CAChC,CAAC,aAAa,EAAEP,WAAW,yEAAyE,EAAE5F,gBAAO,CAACC,eAAe,CAC1HC,MAAM,GACNqG,UAAU,CAACX,YAAY,SAAS,CAAC;QAExC,OAAO;YACLQ,qBAAqBC;QACvB;IACF;IAEAG,iBAAiBnB,OAAO7F,QAAQnB,QAAQD,OAAOgI,oBAAoBX;AACrE;AAEA,MAAMe,mBAAmB,CACvBnB,OACA7F,QACAnB,QACAD,OACAqI,cACAhB;IAEA,qFAAqF;IACrF,IAAIzF,gBAAO,CAACC,eAAe,CAACC,MAAM,GAAGwG,YAAY,CAACrB,QAAQ;QACxD,MAAMsB,cAActB;QACpB,IAAIsB,WAAW,CAACF,aAAa5H,aAAa,CAAC,EAAE;YAC3C,IAAIsG,OAAOwB,WAAW,CAACF,aAAa5H,aAAa,CAAC,CAACI,WAAW,MAAMwG,UAAU;gBAC5E,MAAM,IAAII,6BAAqB;YACjC;QACF,OAAO;YACLc,WAAW,CAACF,aAAa5H,aAAa,CAAC,GAAG;gBACxC,CAACI,WAAW,EAAEwG;YAChB;QACF;IACF,OAAO;QACLpH,MAAM,CAACD,MAAMS,aAAa,CAAC,GAAG;YAC5B,CAAC4H,aAAa5H,aAAa,CAAC,EAAE;gBAC5B,CAACI,WAAW,EAAEwG;YAChB;QACF;IACF;IAEA,IAAIjG,QAAQ;QACV,MAAMoH,QAAQpH,OAAOqH,QAAQ,CAACJ,aAAa5H,aAAa;QACxD,kEAAkE;QAClE,IAAI+H,OAAO;YACT,MAAME,eAAe,OAAOF,UAAU,WAAWA,KAAK,CAAC3H,WAAW,GAAG2H;YACrE,IAAIzB,OAAO2B,kBAAkBrB,UAAU;gBACrC,MAAM,IAAII,6BAAqB;YACjC;QACF,OAAO;YACL,0HAA0H;YAC1HrG,OAAOuH,QAAQ,CAACN,aAAa5H,aAAa,EAAE;gBAC1C,CAACI,WAAW,EAAEwG;YAChB;QACF;IACF;AACF;AAOO,eAAe/H,oBAAoB8B,MAAyB;IACjE,IAAI,CAACA,QAAQN,IAAI;QACfc,gBAAO,CAACe,MAAM,CAACiG,IAAI,CAAC,CAAC,uDAAuD,CAAC;QAC7E;IACF;IAEA,MAAMxG,UAAU6C;IAChB,MAAM4D,aAAa,MAAM,AAACzG,QAAQ0G,WAAW,CAAyBhC,OAAO,CAACiC,SAAS,CAAC3H,OAAOgE,MAAM;IACrG,IAAI,CAACyD,YAAY;QACfjH,gBAAO,CAACe,MAAM,CAACoD,KAAK,CAAC,CAAC,iDAAiD,EAAE3E,OAAOgE,MAAM,CAAC,CAAC;QACxF;IACF;IACA,MAAM4D,gBAAgB,AACpB,CAAA,MAAMH,WAAWI,OAAO,CAAC,CAAC;kBACZ,EAAEC,6BAA6B9H,OAAON,EAAE,EAAE;;;;;;;;;;;;;;;OAerD,CAAC,CAAA,EACJqI,IAAI;IACN,kEAAkE;IAClE,MAAM,EAAEC,MAAM,EAAEC,SAAS,EAAE7C,IAAI,EAAE,GAAGwC;IACpC5I,OAAOkB,MAAM,CAACF,QAAQ;QACpB,GAAG4H,aAAa;QAChBI,QAAQA,QAAQE;QAChBD,WAAWA,WAAWC;QACtB9C,MAAMA,MAAM8C;QACZxI,IAAIM,OAAON,EAAE;IACf;AACF;AAWO,eAAevB,kBAAkBU,MAMvC;IACC,MAAMmC,UAAUC;IAChB,MAAM6C,aAAa5C,IAAAA,aAAM,EACvBF,UAAUA,QAAQ8C,UAAU,GAAG3C,oBAAoB2C,UAAU,EAC7D;IAEF,MAAM1D,MAAMc,IAAAA,aAAM,EAACF,UAAUA,QAAQZ,GAAG,GAAGe,oBAAoBf,GAAG,EAAE;IAEpE,MAAM,EAAE+H,OAAO,EAAE3D,SAAS,EAAEP,MAAM,EAAEQ,KAAK,EAAEC,WAAW,EAAE,GAAG7F;IAE3D,MAAM,EACJuJ,mBAAmB,EACnBC,8BAA8B,EAC9BC,6BAA6B,EAC7BC,oBAAoB,EACpBC,qBAAqB,EACrBC,oBAAoB,EACrB,GAAG,MAAM3E,WAAW4E,kBAAkB;IACvC,MAAMnI,UAAUJ,6BAA6BC,KAAKgI,qBAAqB,EAAE;IAEzE,MAAMO,WAAW;IACjB,IAAIC,WAAyE;QAAEC,OAAOF;QAAUG,aAAa;IAAK;IAClH,MAAMC,UAA4F,EAAE;IAEpG,IAAIZ,WAAWA,QAAQzB,MAAM,GAAG,GAAG;QACjC,IAAI;YACF,MAAOkC,SAASE,WAAW,CAAE;gBAC3B,MAAME,UAAU,MAAMzI,QAAQ0I,QAAQ,CAAC;oBACrC1C,QAAQ;wBACN,CAAC8B,+BAA+B,EAAE;4BAChCa,IAAIf;wBACN;wBACA9E,OAAO;4BACL8F,SAAS;wBACX;wBACAC,UAAU;4BACRC,OAAO;gCAAC;gCAAU;gCAAc;6BAAY;wBAC9C;oBACF;oBACAR,OAAOD,SAASC,KAAK;oBACrBS,OAAOV,SAASW,SAAS;gBAC3B;gBACAR,QAAQS,IAAI,IAAKR;gBACjBJ,WAAWI,QAAQS,UAAU,CAACb,QAAQ;YACxC;QACF,EAAE,OAAOjE,OAAO;YACdnE,gBAAO,CAACe,MAAM,CAACyD,IAAI,CAAC;gBAAEC,aAAa;gBAAMN;gBAAOwD;YAAQ,GAAG;YAC3D,MAAMxD;QACR;QAEA,KAAK,MAAMlD,UAAUsH,QAAS;YAC5B,8EAA8E;YAC9E,IAAIvI,gBAAO,CAACC,eAAe,CAACC,MAAM,GAAGgJ,OAAO,CAACjI,MAAM,CAAC+G,sBAAsB,KAAK/G,OAAO4B,KAAK,EAAEf,WAAW,eAAe;gBACrH9B,gBAAO,CAACe,MAAM,CAACyD,IAAI,CAAC;oBAAEhB,QAAQvC,OAAO/B,EAAE;gBAAC,GAAG;gBAC3C;YACF;YAEA,IAAI;gBACF,MAAMiK,0BAA0BnJ,gBAAO,CAACC,eAAe,CAACC,MAAM,GAAGC,GAAG,CAACP,KAAKmI,qBAAqBqB,eAAe;gBAC9G,MAAMD,uBAAuB,CAACpB,qBAAqBlJ,aAAa,CAAC,CAAC;oBAChE,CAACiJ,8BAA8B,EAAE;wBAC/BuB,MAAM;4BACJC,OAAOrI,OAAO/B,EAAE;wBAClB;wBACAqK,QAAQtI,OAAOsI,MAAM;wBACrBvF;wBACAP;wBACA,GAAIwE,uBAAuB;4BAAEhE;wBAAM,IAAInF,SAAS;oBAClD;oBACAoF;gBACF;YACF,EAAE,OAAOC,OAAO;gBACd,mEAAmE;gBACnEnE,gBAAO,CAACe,MAAM,CAACiG,IAAI,CAAC;oBAAEvC,aAAa;oBAAMN;oBAAOkF,MAAMpI;gBAAO,GAAG;YAClE;QACF;IACF,OAAO;QACL,MAAM,IAAIoD,+BAAuB,CAAC;IACpC;AACF;AAEO,SAASzG;IACd,MAAM4C,UAAU6C;IAEhB,IAAI,CAAC7C,QAAQkB,KAAK,CAAC8H,iBAAiB,EAAE;QACpC,MAAM,IAAIC,gCAAwB,CAChC;IAEJ;IACA,IAAI,CAACjJ,QAAQkJ,OAAO,EAAE;QACpB,MAAM,IAAIC,uCAA+B,CACvC;IAEJ;IACAnJ,QAAQkJ,OAAO,CAACE,GAAG,CAAC,QAAQ;QAAE,CAAC3K,WAAW,EAAEuB,QAAQkB,KAAK,CAAC8H,iBAAiB,CAACtK,EAAE;IAAC;AACjF;AAEO,SAASpB;IACd,MAAM0C,UAAU6C;IAEhB,IAAI,CAAC7C,QAAQkJ,OAAO,EAAE;QACpB,MAAM,IAAIC,uCAA+B,CAAC;IAC5C;IACAnJ,QAAQkJ,OAAO,CAAC/H,MAAM,CAAC;AACzB;AAEO,eAAe9D,+BAA+BQ,MAAiB;IACpE,MAAMmC,UAAU6C;IAChB,MAAM,EAAEzD,GAAG,EAAE8B,KAAK,EAAE,GAAGlB;IACvB,MAAMT,UAAUH,IAAIiK,QAAQ,CAACC,IAAI;IAEjC,MAAMA,OAAO,AAAC,CAAA,MAAM/J,QAAQ0I,QAAQ,CAAC;QAAE1C,QAAQ;YAAEgE,OAAO;gBAAEC,QAAQ3L,OAAO0L,KAAK;YAAC;QAAE;IAAE,EAAC,CAAE,CAAC,EAAE;IACzF,IAAI9I,SAAS;IACb,IAAI6I,QAAQzL,OAAO4L,QAAQ,IAAIH,KAAKG,QAAQ,EAAEC,MAAM;QAClD,IAAI,MAAMlK,gBAAO,CAACC,eAAe,CAACkK,MAAM,GAAGC,OAAO,CAAC/L,OAAO4L,QAAQ,EAAEH,KAAKG,QAAQ,CAACC,IAAI,GAAG;YACvFxI,MAAM8H,iBAAiB,GAAGM;YAC1B7I,SAAS;QACX;IACF;IACAjB,gBAAO,CAACe,MAAM,CAACyD,IAAI,CAAC;QAAEuF,OAAO1L,OAAO0L,KAAK;QAAEM,QAAQP,MAAM5K;QAAI+B;IAAO,GAAG;IAEvE,IAAI,CAACA,QAAQ;QACX,MAAM,IAAI4D,MAAM;IAClB;AACF;AAEA;;CAEC,GAED,SAASlC;IACP,OAAO3C,gBAAO,CAACC,eAAe,CAACqK,eAAe,GAAGC,SAAS,CAACC,0BAAgB,EAAE;AAC/E;AAEA;;CAEC,GACD,SAASnH;IACP,OAAO3C,IAAAA,aAAM,EAAC+J,kCAAyB,CAACC,QAAQ,IAAI;AACtD;AAEA;;CAEC,GACD,SAASjK;IACP,OAAOgK,kCAAyB,CAACC,QAAQ;AAC3C;AAEA,SAAS/J;IACP,OAAOD,IAAAA,aAAM,EAACV,gBAAO,CAAC2K,cAAc,CAACxK,GAAG,CAAC,mBAAmB;AAC9D;AAEA,MAAMlB,aAAa;AAEnB,SAASqC,mBAAmBlD,KAAoB,EAAEoB,MAAgC;IAChF,MAAMoL,wBAAwB5K,gBAAO,CAACC,eAAe,CAACC,MAAM,GAAG2K,KAAK,CAACrM,OAAOC,MAAM,CAACL,MAAMM,MAAM,GAAoB;IACnH,OAAOsB,gBAAO,CAACC,eAAe,CAACC,MAAM,GAAG4K,MAAM,CAACtL,QAAQ,CAACuL,GAAQC,IAAWJ,qBAAqB,CAACI,EAAE,EAAEC;AACvG;AAEA,SAAS7J,kBAAkBhD,KAAoB,EAAEoB,MAAgC;IAC/E,MAAM0L,UAAU1L,OAAO0L,OAAO;IAC9B,MAAMC,aAAa3M,OAAO4M,IAAI,CAACF,SAASG,MAAM,CAAC,CAACC,OAAOzK;QACrDyK,KAAK,CAACzK,IAAI,GAAGrB,MAAM,CAACqB,IAAI;QACxB,OAAOyK;IACT,GAAG,CAAC;IACJ,OAAOhK,mBAAmBlD,OAAO+M;AACnC;AAEA,MAAM/L,0BAA0B,CAACP;IAC/B,MAAM0B,WAAWgL,wBAAc,CAAC,CAAC,IAAI,EAAE1M,cAAc,CAAC,CAAC;IACvD,IAAI,CAAC0B,UAAU;QACb,MAAM,IAAIH,qBAAa,CAAC,CAAC,MAAM,EAAEvB,cAAc,sCAAsC,CAAC,EAAE;YACtF2M,yBAAyBhN,OAAO4M,IAAI,CAACG,wBAAc;QACrD;IACF;IAEA,OAAO9L,mBAAmBc;AAC5B;AAEA,MAAMd,qBAAqB,CAACc;IAC1B,IAAI,CAACA,UAAU;QACb,MAAM,IAAIH,qBAAa,CAAC,CAAC,gFAAgF,CAAC;IAC5G;IAEA,MAAMhC,QAAQqN,mBAAS,CAAClL,SAAS;IACjC,IAAI,CAACnC,OAAO;QACV,MAAM,IAAIgC,qBAAa,CAAC,CAAC,oBAAoB,EAAEG,SAAS,sCAAsC,CAAC,EAAE;YAC/FmL,oBAAoBlN,OAAO4M,IAAI,CAACK,mBAAS;QAC3C;IACF;IAEA,OAAOrN;AACT;;UAEYuN;;;;;;;;;;;;;;;;;;;;;;;;;;IA0BV;;;GAGC;;;;GA7BSA,cAAAA;;AAyCZ,MAAMC,kBAAkB,CAACC;IACvB,MAAMC,WAAWD,UAAUE,UAAU,CAAC,KAAK;IAC3C,OAAO,CAAC,kBAAkB,EAAED,SAAS,CAAC;AACxC;AAEA,MAAMvG,iBAAiBqG,gBAAgB;AACvC,MAAMpG,qBAAqBoG,gBAAgB;AAE3C,MAAMtE,+BAA+B,CAACpI,KAAe,CAAC,4BAA4B,EAAEA,GAAG,CAAC"}